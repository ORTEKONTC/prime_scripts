## Базовый класс скрипта

Для использования скрипта в системе, он должен быть реализован в виде класса и наследовать от базового класса скрипта. Базовый класс скрипта предоставляет необходимый интерфейс и функциональность для интеграции скрипта с системой.

## Поля

- ***scriptParameters*** Параметры сценария в формате `PyDict`

## Методы

- ***get_uid()*** Возвращает уникальный идентификатор сценария типа `int`
- ***is_initialized()*** Возвращает флаг инициализации типа `bool`
- ***set_initialized()*** Устанавливает флаг инициализации в `True`
- ***get_script_parameters()*** - Возвращает параметры сценария типа `PyDict`

#### Следующие методы должны быть реализованы в разрабатываемом скрипте:
- ***on_event(event)*** Обработка события. Аргументы:
  - ***event*** Событие типа `PyDict`. [Структура события](/event_structure.md).

## Использование

```python
from script_base import Script

class MyScript(Script):
    def __init__(self, uid, script_parameters):
        # Вызов конструктора базового класса скрипта
        super().__init__(uid, script_parameters)

        # Код инициализации скрипта ...

        # Установка флага инициализации
        self.set_initialized()

    def on_event(self, event):

        # Обработка события ...

        # Возврат RPC команды
        return some_rpc_command
```

# API

## Функции

- ***get_zone_state(zoneId)*** Получение состояния зоны в виде массива событий типа `PyDict`. Аргументы:
    - ***zoneId*** Id зоны типа `uint32_t`
- ***get_zone_instant_events(zoneId)*** Получение мгновенных событий зоны в виде массива событий типа `PyDict`. Аргументы:
    - ***zoneId*** Id зоны типа `uint32_t`
- ***post_message(message)*** Отправка сообщения в брокер. Аргументы:
    - ***message*** Сообщение типа `char*`

## Использование

```python
import API

eventList = API.get_zone_state(zoneId)

instantEventList = API.get_zone_instant_events(zoneId)

API.post_message(command_rpc)
```

# TimerFactory и Timer

## Функции TimerFactory

- ***create_timer(duration, callback, autoRestart=False, enabled=True)*** Создает таймер с заданными параметрами. Аргументы:
    - ***duration*** Продолжительность отсчета таймера в миллисекундах типа `long`
    - ***callback*** Функция, которая будет вызвана по истечении времени таймера
    - ***autoRestart*** Булево значение, указывающее, должен ли таймер автоматически перезапускаться после истечения времени. По умолчанию установлено в `False`.
    - ***enabled*** Булево значение, определяющее, включен ли таймер сразу после его создания. По умолчанию установлено в `True`.

## Поля класса Timer
- ***duration*** Продолжительность отсчета таймера в миллисекундах типа `long`.
- ***callback*** Функция, которая будет вызвана по истечении времени таймера.
- ***auto_restart*** Булево значение, указывающее, должен ли таймер автоматически перезапускаться после истечения времени.
- ***enabled*** Булево значение, определяющее, включен ли таймер. Если False, таймер не будет запускаться независимо от других параметров.
- ***is_started*** Булево значение только для чтения, показывающее, запущен ли таймер.
- ***is_finished*** Булево значение только для чтения, показывающее, завершился ли таймер после истечения времени.
- ***is_paused*** Булево значение только для чтения, показывающее, находится ли таймер в приостановленном состоянии.

## Методы класса Timer
- ***start()*** Запускает таймер.
- ***stop()*** Останавливает таймер, если он был запущен.
- ***restart()*** Перезапускает таймер, сбрасывая его время отсчета.
- ***reset()*** Сбрасывает таймер, устанавливая его в начальное состояние.
- ***pause()*** Приостанавливает таймер.
- ***resume()*** Продолжает таймер после приостановки.

## Использование

Для использования класса `TimerFactory` и `Timer`, следует импортировать модуль `TimerFactory` и создать объекты таймеров с помощью функции `create_timer`. Пример использования:
        
```python
import TimerFactory

class MyClass():
    def __init__(self):
        self.timer1 = TimerFactory.create_timer(1000, self.my_func1)
        self.timer2 = TimerFactory.create_timer(5000, self.my_func2, True, False)
        # Запуск таймера
        self.timer1.start()

        # Приостановка таймера
        self.timer1.pause()

        # Продолжение работы таймера после приостановки
        self.timer1.resume()

    def my_func1(self):

        # Обработка функции ...
        
        # Включение таймера
        self.timer2.enabled = True
        # Запуск таймера
        self.timer2.start()

    def my_func2(self):

        # Обработка функции ...
```
